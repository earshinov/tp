class CsvReader {
	constructor() {
		this._records = {}; // recordNo => _Record | Record
		this._objects = []; // Obj[]
	}
	read(csv, callback) {
		var me = this;

		var readable = new stream.Readable();
		readable.push(csv);
		readable.push(null);

		var parser = parse(ParserSettings);
		readable.pipe(parser);

		var skipRows = Settings.skipRows;
		parser.on("readable", function() {
			var record;
			while ((record = parser.read())) {
				if (skipRows > 0) {
					--skipRows;
					continue;
				}
				record = record.map(x => x.trim());
				me._processRecord(record);
			}
		});
		parser.on("error", function(ex) {
			callback(new CsvError(parser.lines, ex));
		});
		parser.on("finish", function() {
			for (var key in me._records)
				if (me._records.hasOwnProperty(key))
					me._records[key] = me._records[key].finish();
			callback();
		});
	}
	_processRecord(record) {
		var recordNo = record[3];
		if (!recordNo)
			// не обрабатываем строки без номера записи
			return;

		recordNo = utils.parseInt(recordNo);
		if (recordNo == null)
			throw new Error("Некорректный номер записи: " + record[2]);

		var source = record[1];
		if (!source)
			throw new Error("Отсутвует строка записи");
		var records = this._records;
		if (!(recordNo in records))
			records[recordNo] = new _Record();
		records[recordNo].appendSource(source);

		var objectType = record[4];
		if (!objectType) {
			// строка без объекта
			for (var i = 5; i < record.length; i++)
				if (record[i])
					throw new Error("Строка, не содержащая тип объекта, не должна содержать информации об объекте");
			return;
		}

		var number = record[5];
		// номер объекта опциональный для нежилых помещений
		if (!number || number == "бн")
			number = null;
		else {
			number = utils.parseInt(number);
			if (number == null)
				throw new Error("Некорректный номер объекта: " + record[5]);
		}

		var building = utils.parseInt(record[6]);
		if (building != 1 && building != 2)
			throw new Error("Некорректный номер корпуса: " + record[6]);

		var area = parseCsvFloat(record[9]);
		if (area == null)
			throw new Error("Некорректное значение площади: " + record[9]);

		if (objectType == "машиноместо") {
			if (number == null)
				throw new Error("Некорректный номер объекта: " + record[5]);
			this._objects.push(new m.ParkingPlace(recordNo, number, building, area));
			return;
		}

		var section = record[8];
		// номер секции опциональный
		if (!section || section == "нет" || section == "?")
			section = null;
		else {
			section = utils.parseInt(section);
			if (section == null)
				throw new Error("Некорректный номер секции: " + record[8]);
		}

		if (objectType == "неж пом" || objectType.search(/предприятие/i) >= 0 || objectType == "магазин" || objectType == "офис") {
			this._objects.push(new m.NonResidentialPremise(recordNo, objectType, number, building, section, area));
			return;
		}

		var floor = utils.parseInt(record[7]);
		if (floor == null)
			throw new Error("Некорректный номер этажа: " + record[7]);

		if (number == null)
			throw new Error("Некорректный номер объекта: " + record[5]);
		this._objects.push(new m.Apartment(recordNo, objectType, number, building, floor, section, area));
	}
	getData() {
		return {
			records: this._records,
			objects: this._objects,
		};
	}
}

module.exports = CsvReader;

var parse = require("csv-parse");
var stream = require("stream");
var utils = require("app/utils");
var CsvError = require("app/exceptions/CsvError");
var m = require("app/model/ModelClasses.js");

var ParserSettings = {
	delimiter: "\t",
	relax_column_count: true,
};
var Settings = {
	skipRows: 1,
};

function parseCsvFloat(value) {
	value = value.replace(/,/g, ".");
	return utils.parseFloat(value);
}

class _Record {
	constructor() {
		this._source = [];
	}
	appendSource(source) {
		this._source.push(source);
	}
	finish() {
		return new m.Record(this._source.join(""));
	}
}
